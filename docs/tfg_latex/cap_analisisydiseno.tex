\chapter{Análisis, arquitectura y diseño del sistema}
\label{chap:sistemadesarrollado}

\lsection{Análisis}

Este apartado es trabajo hecho a priori antes de presentar la solicitud de TFG que muestra la viabilidad del proyecto.

\subsection{Descripción del producto}
\producto es un producto que permite al usuario ver a través de los ojos de un avatar. Esto se consigue gracias a unas gafas de realidad virtual (figura \ref{fig:googlecardboard}) conectadas por Internet a un robot con dos cámaras por ojos. Los movimientos de la cabeza del usuario serán también transmitidos a través de la red hasta llegar al robot, que ejecuta un programa que recibe estos datos y actualiza la orientación de las cámaras en tiempo real para dar la sensación al usuario final de estar en otro cuerpo.

%\todo[inline]{Referencia a gafas de VR: \currentname}
%\subsection{Viabilidad}
%
%\todo[inline]{Análisis: \currentname}

\subsection{Objetivos y funcionalidad}

El objetivo principal del proyecto es el de desarrollar un sistema con los siguientes tres elementos:
\begin{enumerate}
\item Dos \textbf{servidores de vídeo} que reciban como entrada un dispositivo cada uno (en este caso, una cámara por servidor) y como salida ofrezcan un \textit{stream} multimedia.
\item Un \textbf{servidor de control} que reciba el posicionamiento del dispositivo de realidad virtual y asigne un valor analógico a los actuadores a partir de las coordenadas, que serán los motores sobre los que se encuentra la estructura en la que reposen las cámaras.
\item Una \textbf{aplicación para dispositivo smartphone} que establezca la conexión con los servidores. Recibirá como entrada dos \textit{streams} de vídeo (uno por cada ojo) y como salida enviará la rotación respecto de los tres ejes dimensionales.
\end{enumerate}

\begin{figure}[h]
	\centerline{
		\mbox{\includegraphics[width=4.00in]{images/diagrama_red_fisico.png}}
	}
	\caption{\textbf{Diagrama conceptual de la red del sistema}}
	\label{fig:diagrama_red}
\end{figure}


Sólo existe un tipo de usuario de la aplicación y, en un principio, su interacción se limitará a la siguiente:

\begin{itemize}
	\item Alterar la posición física de las gafas de realidad virtual girando la cabeza.
	\item Modificar la dirección IP y los puertos de sendos servidores a través de la pantalla táctil del smartphone.
\end{itemize}




El sistema no debería necesitar ningún tipo de persistencia. Las conexiones se realizarían en modo \textit{stateless}, lo que quiere decir el cliente se conecta y desconecta de los servidores arbitrariamente sin que deban almacenarse datos de sesión algunos.

\subsection{Requisitos}
\begin{enumerate}
	\item Las imágenes se transmiten y se muestran con baja latencia.
	\item Los distintos objetos comunes en las dos imágenes se pueden apreciar en tres dimensiones.
	\item Los consecutivos movimientos de la cabeza son transmitidos secuencialmente y con baja latencia.	
	\item El usuario puede modificar la dirección IP de cada servidor.
	\item El usuario puede modificar el puerto de cada servidor.
\end{enumerate}
\subsection{Tamaño y rendimiento}
Esta arquitectura del software está orientada a permitir exclusivamente una conexión simultánea. Al tratarse de una aplicación en tiempo real, más conexiones podrían congestionar el tráfico en la red y saturar los recursos de los servidores. Además, la rotación de los motores sólo debería controlarse desde un solo cliente.



\lsection{Arquitectura}

\subsection{Vista estática}

El cliente es el componente central de este sistema heterogéneo. Éste está compuesto a su vez de otros tres componentes que se ejecutan como hilos independientes en la app. Uno de ellos envía periódicamente la orientación del dispositivo al servidor de control en datagramas a través del protocolo de transporte UDP. Los otros dos reciben un stream de vídeo cada uno, procedentes de los servidores de vídeo a través del protocolo de aplicación RTSP. El servidor de control está conectado a su vez con el Arduino por medio de USB, al igual que las cámaras están conectadas a la máquina en la que se ejecutan los servidores de vídeos también por USB. Estas relaciones entre los componentes se pueden visualizar en la figura~\ref{fig:diagrama_componentes}

\begin{figure}[h]
	\centerline{
		\mbox{\includegraphics[width=4.00in]{images/diagrama_componentes.png}}
	}
	\caption{\textbf{Diagrama de componentes del sistema}. Se pueden apreciar los distintos componentes, las interfaces que ofrecen y requieren y el protocolo que utilizan para comunicarse entre sí.}
	\label{fig:diagrama_componentes}
\end{figure}



\subsection{Vista funcional} % La visión funcional: describe qué hace cada componente.

%Descripción por separado de los componentes del sistema.

\subsubsection{Servidor de vídeo}
%\todo[inline]{Vista funcional: \currentname}

La funcionalidad de este componente dentro del sistema es la de proveer al cliente de dos flujos continuos de vídeo. Estos deben poder ser referenciados y accedidos a través de una dirección IP y de un puerto, bien dentro de la red local o bien a través de Internet. 

\subsubsection{Servidor de control}
%\todo[inline]{Vista funcional: \currentname}

Este servidor también debe poder referenciarse del mismo modo que el anterior. Recibirá constantemente la posición desde el cliente que transformará en instrucciones para mover la estructura sobre la que se encuentren las cámaras.

\subsubsection{Cliente móvil}
%\todo[inline]{Vista funcional: \currentname}

Finalmente, el cliente se integra junto a estas partes anteriores de la siguiente forma: por un lado, ha de poder conectarse a los dos servidores de vídeo a través de sus direcciones para recibir sendos flujos de fotogramas que se mostrarán a través de la pantalla; por otro lado, ha de enviar continuamente sus coordenadas polares al servidor de control para que el Arduino pueda hacer girar el motor consecuentemente.

\subsection{Vista dinámica} % La visión dinámica: describe cómo se comportan los componentes a lo largo del tiempo y como interactúan entre sí.
%\todo[inline]{\currentname}
Prácticamente toda la evolución del sistema a lo largo del tiempo puede observarse en el diagrama \ref{fig:diagrama_actividad_app}, correspondiente al cliente. Por otro lado, los servidores pueden estar esperando a una conexión (el cliente todavía no se ha conectado) o enviando/recibiendo un flujo de datos.

\begin{figure}[p]
	\centerline{
		\mbox{\includegraphics[width=7.00in]{images/diagrama_actividad.png}}
	}
	\caption{\textbf{Diagrama de actividad de la aplicación para Android}. En ocre, las vistas de la aplicación. En azul, las interacciones del usuario. En rojo, las respuestas del sistema.}
	\label{fig:diagrama_actividad_app}
\end{figure}

\newpage


\lsection{Diseño} 

\subsection{Servidor de vídeo}
%\todo[inline]{Diseño: \currentname}

Como se explica en el apartado de implementación, esta parte del sistema no se ha llevado a cabo programando, sino utilizando una herramienta \textit{open source}.

\subsection{Servidor de control}
%\todo[inline]{Diseño: \currentname}

El servidor de control está implementado en Python y son dos las clases más importantes, como se detalla en la figura \ref{fig:diagrama_clases_servidor_control}:

\begin{itemize}
	
	\item \textbf{\textit{ServoControl}}: posee un objeto \textit{Serial} correspondiente al puerto USB en el que está conectado el Arduino y un valor tipo \textit{float} que representa el último ángulo procesado. El método \textit{moveAngle} mueve desde el ángulo actual hasta el ángulo objetivo.
	\item \textbf{\textit{UDPServer}}: guarda la dirección y el puerto en la cual será desplegado. El método \textit{bind()} solicita al sistema operativo escuchar los paquetes de la interfaz de red que lleguen a cierta IP y puerto y \textit{recvfrom()} lee datos del socket con un cierto tamaño de buffer (\textit{bufferSize}).

\end{itemize}

\begin{figure}[h]
	\centerline{
		\mbox{\includegraphics[width=4.00in]{images/diagrama_clases_servidor_control.png}}
	}
	\caption{\textbf{Diagrama de clases del servidor de control}}
	\label{fig:diagrama_clases_servidor_control}
\end{figure}

\subsection{Cliente móvil}
%\todo[inline]{Diseño: \currentname}

El cliente consta principalmente de cuatro clases Java. Dos de ellas se corresponden con las dos vistas de la aplicación. Para representar esto, las clases han de extender la funcionalidad de \textit{Android.Activity}. Estas dos han de tener acceso al \textit{Singleton} AddressManager, que se encarga de gestionar las direcciones y puertos de los servidores. Por último, la clase MainActivity debe instanciar a la clase PositionSender, que se encarga de establecer un canal de comunicación UDP con el servidor de control y de enviar periódicamente un mensaje con la orientación del dispositivo móvil, obtenida a través de los sensores.

\begin{figure}[h]
	\centerline{
		\mbox{\includegraphics[width=7.00in]{images/diagrama_clases_app.png}}
	}
	\caption{\textbf{Diagrama de clases de la aplicación para Android}}
	\label{fig:diagrama_clases_app}
\end{figure}


%\todo[inline]{Diseño: \textbf{Diagrama de secuencia}}

